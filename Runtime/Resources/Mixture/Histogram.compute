// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Clear 
#pragma kernel ComputeLuminanceBuffer
#pragma kernel ReduceLuminanceBuffer
#pragma kernel GenerateHistogram 
#pragma kernel ComputeHistogramData 

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.alelievr.mixture/Editor/Resources/HistogramData.hlsl"

float4                              _InputTextureSize;


#pragma enable_d3d11_debug_symbols

Texture2D<float4> _Input;

[numthreads(64,1,1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _HistogramBucketCount)
        _Histogram[id.x] = (HistogramBucket)0;

    // TODO: size check
    _ImageLuminance[id.x].minLuminance = 0;
    _ImageLuminance[id.x].maxLuminance = 0;
}

groupshared float g_luminance[64];    

[numthreads(8,8,1)]
void ComputeLuminanceBuffer(uint3 id : SV_DispatchThreadID, int3 gid : SV_GroupThreadID)
{
    float4 input = _Input[id.xy];

    // Insert your code here
    // TODO: shared memory with min max redux
    float minLuminance = Luminance(input);
    float maxLuminance = minLuminance;
    g_luminance[gid.x + gid.y * 8] = minLuminance;

    // Wait for all threads in the group to write in g_luminance
    GroupMemoryBarrierWithGroupSync();

    if (all(gid == 0))
    {
        for (uint x = 0; x < 8; x++)
        {
            for (uint y = 0; y < 8; y++)
            {
                minLuminance = min(minLuminance, g_luminance[x + y * 8]);
                maxLuminance = max(maxLuminance, g_luminance[x + y * 8]);
            }
        }
        
        uint2 dispatchId = id.xy / 8;
        // Push results to image luminance
        _ImageLuminance[dispatchId.x + dispatchId.y * _InputTextureSize.x / 8].minLuminance = minLuminance;
        _ImageLuminance[dispatchId.x + dispatchId.y * _InputTextureSize.x / 8].maxLuminance = maxLuminance;
    }
}

// TODO: optimize
[numthreads(1, 1, 1)]
void ReduceLuminanceBuffer(uint3 id : SV_DispatchThreadID)
{
    float minLuminance, maxLuminance;

    minLuminance = _ImageLuminance[0].minLuminance;
    maxLuminance = _ImageLuminance[0].maxLuminance;

    // TODO: actual reduce instead of stupid loop
    for (int i = 0; i < _InputTextureSize.x * _InputTextureSize.y / 64; i++)
    {
        minLuminance = min(minLuminance, _ImageLuminance[i].minLuminance);
        maxLuminance = max(maxLuminance, _ImageLuminance[i].maxLuminance);
    }

    _ImageLuminance[0].minLuminance = minLuminance;
    _ImageLuminance[0].maxLuminance = maxLuminance;
}

[numthreads(8,8,1)]
void GenerateHistogram(uint3 id : SV_DispatchThreadID)
{
    float4 input = _Input[id.xy];
    LuminanceData data = _ImageLuminance[0]; // the index 0 contains min and max lum of the whole image

    // TODO: histogram modes
    // Compute the normalized luminance
    uint result;
    input = float4(Luminance(input), input.rgb);
    float4 remappedColor = saturate((input - data.minLuminance) / (data.maxLuminance - data.minLuminance));
    remappedColor *= _HistogramBucketCount;
    remappedColor = int4(remappedColor); // Ensure that the color / luminance always end up in the correct bucket
    InterlockedAdd(_Histogram[uint(remappedColor.x)].luminance, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.y)].r, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.z)].g, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.w)].b, 1);
}

[numthreads(64, 1, 1)]
void ComputeHistogramData(uint id : SV_DispatchThreadID)
{
    if (id >= _HistogramBucketCount)
        return;

    // TODO: compute histogram min and max with kernel reduce reduce
    if (id == 0)
    {
        uint maxCount = 0;
        uint minCount = 0;

        for (int i = 0; i < _HistogramBucketCount; i++)
        {
            HistogramBucket b = _Histogram.Load(i);
            uint minB = min(b.luminance, min(b.r, min(b.g, b.b)));
            uint maxB = max(b.luminance, max(b.r, max(b.g, b.b)));
            maxCount = max(maxCount, b.luminance);
            minCount = min(minCount, b.luminance);
        }

        _HistogramData[0].minBucketCount = minCount;
        _HistogramData[0].maxBucketCount = maxCount;
    }
}