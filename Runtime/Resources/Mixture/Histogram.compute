// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Clear
#pragma kernel ClearLuminance
#pragma kernel ComputeLuminanceBuffer
#pragma kernel ReduceLuminanceBuffer
#pragma kernel GenerateHistogram 
#pragma kernel ComputeHistogramData 
#pragma kernel CopyMinMaxToBuffer 

#pragma multi_compile_local CRT_2D CRT_3D CRT_CUBE

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.alelievr.mixture/Editor/Resources/HistogramData.hlsl"
#include "Packages/com.alelievr.mixture/Runtime/Shaders/MixtureFixed.cginc"

float4      _InputTextureSize;
uint        _DispatchSizeX;

#pragma enable_d3d11_debug_symbols

TEXTURE_X(_Input);

[numthreads(8,8,1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * _DispatchSizeX * 8 + id.z * _DispatchSizeX * _DispatchSizeX * 8;

    if (index < _HistogramBucketCount)
        _Histogram[index] = (HistogramBucket)0;

    _ImageLuminance[index] = (LuminanceData)0;
}

[numthreads(8,8,1)]
void ClearLuminance(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * _DispatchSizeX * 8 + id.z * _DispatchSizeX * _DispatchSizeX * 8;
    _ImageLuminance[index] = (LuminanceData)0;
}

groupshared float g_luminance[64];
float3 _RcpTextureSize;

[numthreads(8,8,1)]
void ComputeLuminanceBuffer(uint3 id : SV_DispatchThreadID, int3 gid : SV_GroupThreadID)
{
    float3 uvs = GetDefaultUVsComputeShader(id, _RcpTextureSize);
    float4 input = SAMPLE_X_NEAREST_CLAMP(_Input, uvs, uvs);
    // float4 input = 0;
    // float4 input = _Input[id.xy];

    // Insert your code here
    // TODO: shared memory with min max redux
    float minLuminance = Luminance(input);
    float maxLuminance = minLuminance;
    g_luminance[gid.x + gid.y * 8 + gid.z * 8 * 8] = minLuminance;

    // Wait for all threads in the group to write in g_luminance
    GroupMemoryBarrierWithGroupSync();

    if (all(gid == 0))
    {
        for (uint x = 0; x < 8; x++)
        {
            for (uint y = 0; y < 8; y++)
            {
                minLuminance = min(minLuminance, g_luminance[x + y * 8]);
                maxLuminance = max(maxLuminance, g_luminance[x + y * 8]);
            }
        }
        
        uint2 dispatchId = id.xy / 8;
        // Push results to image luminance
        _ImageLuminance[dispatchId.x + dispatchId.y * _InputTextureSize.x / 8].minLuminance = minLuminance;
        _ImageLuminance[dispatchId.x + dispatchId.y * _InputTextureSize.x / 8].maxLuminance = maxLuminance;
    }
}

uint _LuminanceBufferSize;

[numthreads(8, 8, 1)]
void ReduceLuminanceBuffer(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
    uint index = id.x + id.y * _DispatchSizeX * 8 + id.z * _DispatchSizeX * _DispatchSizeX * 8;

    for (uint i = 1; i < _LuminanceBufferSize; i *= 2)
    {
        uint index = 2 * i * groupIndex;

        // Catch out of boud errors
        if (index < _LuminanceBufferSize)
        {
            _ImageLuminance[index].minLuminance = min(_ImageLuminance[index].minLuminance, _ImageLuminance[index + i].minLuminance);
            _ImageLuminance[index].maxLuminance = max(_ImageLuminance[index].maxLuminance, _ImageLuminance[index + i].maxLuminance);
        }
        GroupMemoryBarrierWithGroupSync();
    }
}

[numthreads(8,8,1)]
void GenerateHistogram(uint3 id : SV_DispatchThreadID)
{
    float3 uvs = GetDefaultUVsComputeShader(id, _RcpTextureSize);
    float4 input = SAMPLE_X_NEAREST_CLAMP(_Input, uvs, uvs);
    // float4 input = 0;
    // float4 input = _Input[id.xy];

    LuminanceData data = _ImageLuminance[0]; // the index 0 contains min and max lum of the whole image

    // TODO: histogram modes
    // Compute the normalized luminance
    uint result;
    input = float4(Luminance(input), input.rgb);
    float4 remappedColor = saturate((input - data.minLuminance) / (data.maxLuminance - data.minLuminance));
    remappedColor *= _HistogramBucketCount;
    remappedColor = int4(remappedColor); // Ensure that the color / luminance always end up in the correct bucket
    InterlockedAdd(_Histogram[uint(remappedColor.x)].luminance, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.y)].r, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.z)].g, 1);
    InterlockedAdd(_Histogram[uint(remappedColor.w)].b, 1);
}

[numthreads(64, 1, 1)]
void ComputeHistogramData(uint id : SV_DispatchThreadID)
{
    if (id >= _HistogramBucketCount)
        return;

    // TODO: compute histogram min and max with kernel reduce reduce
    if (id == 0)
    {
        uint maxCount = 0;
        uint minCount = 0;

        for (uint i = 0; i < _HistogramBucketCount; i++)
        {
            HistogramBucket b = _Histogram.Load(i);
            uint minB = min(b.luminance, min(b.r, min(b.g, b.b)));
            uint maxB = max(b.luminance, max(b.r, max(b.g, b.b)));
            maxCount = max(maxCount, b.luminance);
            minCount = min(minCount, b.luminance);
        }

        _HistogramData[0].minBucketCount = minCount;
        _HistogramData[0].maxBucketCount = maxCount;
    }
}

RWStructuredBuffer<LuminanceData> _Target;

[numthreads(1, 1, 1)]
void CopyMinMaxToBuffer(uint id : SV_DispatchThreadID)
{
    _Target[0].minLuminance = _ImageLuminance[0].minLuminance;
    _Target[0].maxLuminance = _ImageLuminance[0].maxLuminance;
}